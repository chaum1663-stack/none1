<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>20/10</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{ --bg1:#050510; --bg2:#0b0b1c; }
  html,body{height:100%; margin:0;}
  body{background: radial-gradient(1200px 800px at 60% 40%, var(--bg2), var(--bg1)); color:#fff; font-family: 'Poppins', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; overflow:hidden;}
  #webgl{position:fixed; inset:0; width:100%; height:100%; display:block;}
  .hud{position:fixed; inset:0; pointer-events:none; display:grid; place-items:center;}
  #bigTitle{opacity:0; transform:translateY(10px) scale(.98); transition:opacity .9s ease, transform .9s cubic-bezier(.2,.8,.2,1);} 
  #bigTitle.show{opacity:1; transform:none;}
  #titleWrap{display:flex; flex-direction:column; align-items:center; gap:.75rem;}
  .plaque{position:relative; padding:.7rem 1.1rem; border-radius:18px; background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.12); box-shadow:0 20px 60px rgba(0,0,0,.35); backdrop-filter: blur(6px);}
  .line-small{font-weight:700; letter-spacing:.12em; text-transform:uppercase; font-size:clamp(11px,2.2vw,13px); text-align:center; opacity:.9}
  .line-main{font-family:'Great Vibes', cursive; font-size:clamp(42px,6.8vw,72px); line-height:1; text-align:center; background: linear-gradient(120deg, #ffd1d9 0%, #ff6b8a 25%, #ff2f55 50%, #ff7aa2 75%, #ffd1d9 100%); background-size: 220% 220%; -webkit-background-clip:text; background-clip:text; color: transparent; text-shadow: 0 6px 36px rgba(255,64,96,.35), 0 2px 0 rgba(255,255,255,.45); position:relative; letter-spacing:.02em; animation: hueShift 8s ease-in-out infinite;}
  .line-main::after{content:""; position:absolute; inset:0; background: linear-gradient(75deg, transparent 45%, rgba(255,255,255,.85) 50%, transparent 55%); transform: translateX(-120%); filter: blur(1px); mix-blend-mode: screen; animation: shimmer 2.8s ease-in-out 1.2s both;}
  @keyframes shimmer{to{transform: translateX(120%);} } @keyframes hueShift{0%{filter:hue-rotate(0deg)}50%{filter:hue-rotate(-10deg)}100%{filter:hue-rotate(0deg)}}
</style>
</head>
<body>
  <canvas id="webgl"></canvas>
  <div class="hud">
    <div id="bigTitle">
      <div id="titleWrap">
        <div class="plaque">
          <div class="line-small">Ch√∫c em 20/11 dui do·∫ª h·∫°nh ph√∫c, xinh c√†ng xinhh nho√°aaa</div>
          <div class="line-main"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(function(){
  // ====== STATE ======
  let phase = 'idle';
  let titleShown = false; // show after formed only
  const HEART_SCALE = 2.8;

  // ====== THREE SETUP ======
  const DPR = Math.max(1, Math.min(2.5, devicePixelRatio || 1));
  const canvas = document.getElementById('webgl');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
  renderer.setPixelRatio(DPR); renderer.setSize(innerWidth, innerHeight);
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 300);
  camera.position.set(0, 1.2, 10.0);
  addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }, {passive:true});

  const contentGroup = new THREE.Group(); scene.add(contentGroup);
  scene.add(new THREE.AmbientLight(0x8899ff, 0.35)); const keyLight = new THREE.DirectionalLight(0xffffff, 0.9); keyLight.position.set(5, 6, 8); scene.add(keyLight);

  // simple manual orbit (no OrbitControls)
  let isDragging=false, lastX=0, lastY=0, yaw=0, pitch=0, autoRotate=0.22;
  function posFromEvent(e){ return {x: (e.touches? e.touches[0].clientX : e.clientX), y: (e.touches? e.touches[0].clientY : e.clientY)} }
  function onDown(e){ isDragging=true; const p=posFromEvent(e); lastX=p.x; lastY=p.y; document.body.style.cursor='grabbing'; }
  function onUp(){ isDragging=false; document.body.style.cursor='default'; }
  function onMove(e){ if(!isDragging) return; const p=posFromEvent(e); const dx=p.x-lastX, dy=p.y-lastY; lastX=p.x; lastY=p.y; yaw += dx*0.005; pitch += dy*0.003; pitch=Math.max(-1.0,Math.min(1.0,pitch)); }
  canvas.addEventListener('mousedown', onDown); addEventListener('mouseup', onUp); addEventListener('mousemove', onMove);
  canvas.addEventListener('touchstart', onDown, {passive:true}); addEventListener('touchend', onUp, {passive:true}); canvas.addEventListener('touchmove', onMove, {passive:true});

  // ====== BACKDROP STARS ======
  const starGroup = new THREE.Group(); scene.add(starGroup);
  const STAR_COUNT_BG = 2600; const starGeoBG = new THREE.BufferGeometry(); const starPosBG = new Float32Array(STAR_COUNT_BG*3);
  for(let i=0;i<STAR_COUNT_BG;i++){ const r = 80 * Math.cbrt(Math.random()); const th = Math.random()*Math.PI*2; const ph = Math.acos(2*Math.random()-1); starPosBG[i*3+0] = r*Math.sin(ph)*Math.cos(th); starPosBG[i*3+1] = r*(Math.sin(ph)*Math.sin(th))*0.7; starPosBG[i*3+2] = r*Math.cos(ph); }
  starGeoBG.setAttribute('position', new THREE.BufferAttribute(starPosBG, 3));
  const starMatBG = new THREE.PointsMaterial({ color:0xffffff, size:0.055, sizeAttenuation:true, depthWrite:false, transparent:true, opacity:0.9 });
  starGroup.add(new THREE.Points(starGeoBG, starMatBG));

  // ====== SHOOTING STARS (meteors) ======
  const meteorGroup = new THREE.Group(); scene.add(meteorGroup);
  function makeStreakTexture(){
    const c=document.createElement('canvas'); c.width=256; c.height=64; const ctx=c.getContext('2d');
    const g=ctx.createLinearGradient(0,32,256,32); g.addColorStop(0,'rgba(255,255,255,0)'); g.addColorStop(0.25,'rgba(255,255,255,0.5)'); g.addColorStop(1,'rgba(255,255,255,1)');
    ctx.fillStyle=g; ctx.fillRect(0,16,256,32); return new THREE.CanvasTexture(c);
  }
  const streakTex = makeStreakTexture();
  const METEOR_N = 28; const meteors=[];
  function spawnMeteor(m){
    const s = meteors[m];
    const radius = 70 + Math.random()*40; // xa camera
    const ang = Math.random()*Math.PI*2;
    s.sprite.position.set(Math.cos(ang)*radius, -10 - Math.random()*40, Math.sin(ang)*radius);
    const spd = 25 + Math.random()*25; // t·ªëc ƒë·ªô
    s.vel.set(-spd*0.7, spd, -spd*0.5); // xi√™n ch√©o b·∫ßu tr·ªùi
    s.life = 2.5 + Math.random()*2.0;
    s.sprite.material.opacity = 0.9;
    s.sprite.material.rotation = Math.atan2(s.vel.y, s.vel.x);
    const len = 6 + Math.random()*10; s.sprite.scale.set(len, 0.5, 1);
  }
  for(let i=0;i<METEOR_N;i++){
    const mat = new THREE.SpriteMaterial({ map: streakTex, transparent:true, depthWrite:false, opacity:0.9, blending:THREE.AdditiveBlending });
    const spr = new THREE.Sprite(mat); meteorGroup.add(spr); meteors.push({sprite:spr, vel:new THREE.Vector3(), life:0}); spawnMeteor(i); }


  // ====== SPECIAL STAR ======
  // Rebuild a prettier "special star": core + glow + orbiting sparkles
  const specialStar = new THREE.Group();
  const specialCore = new THREE.Mesh(
    new THREE.IcosahedronGeometry(0.28, 2),
    new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xfff6cc, emissiveIntensity:1.6, metalness:0.0, roughness:0.18, transparent:true, opacity:0.95 })
  );
  specialStar.add(specialCore);
  const specialGlow = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeStarTexture(256,5,0.35,1.0,'#ffd966'), transparent:true, opacity:0.85, depthWrite:false }));
  specialGlow.scale.set(1.8,1.8,1.8); specialStar.add(specialGlow);
  const specialAura = new THREE.Sprite(new THREE.SpriteMaterial({ color:0xfff0bb, transparent:true, opacity:0.35, depthWrite:false }));
  specialAura.scale.set(2.6,2.6,2.6); specialStar.add(specialAura);
  specialStar.position.set( (Math.random()*2-1)*2.8, 0.9 + Math.random()*1.2, (Math.random()*2-1)*1.2 );
  contentGroup.add(specialStar);
  const sparkOrbiters = [];
  for(let i=0;i<8;i++){
    const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeStarTexture(96,5,0.45,1.0,'#fffacd'), transparent:true, opacity:0.9, depthWrite:false }));
    sp.scale.set(0.35,0.35,0.35); specialStar.add(sp); sparkOrbiters.push(sp);
  }
  let sparkT = 0;
  const raycaster = new THREE.Raycaster(); const pointer = new THREE.Vector2();
  addEventListener('mousemove', (e)=>{ const rect = renderer.domElement.getBoundingClientRect(); pointer.x = ((e.clientX-rect.left)/rect.width)*2-1; pointer.y = -((e.clientY-rect.top)/rect.height)*2+1; raycaster.setFromCamera(pointer, camera); const hit = raycaster.intersectObject(specialStar, true); if(phase==='idle') document.body.style.cursor = hit.length? 'pointer' : (isDragging?'grabbing':'default'); }, {passive:true});

  // ====== STAR SPRITE ======
  function makeStarTexture(size=192, spikes=5, inner=.40, outer=1.0, body='#ff2f55'){
    const c = document.createElement('canvas'); c.width=c.height=size; const ctx = c.getContext('2d');
    ctx.clearRect(0,0,size,size); ctx.save(); ctx.translate(size/2, size/2); ctx.rotate(-Math.PI/2);
    ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.shadowColor = 'rgba(255,80,100,0.9)'; ctx.shadowBlur = size*0.18; ctx.beginPath(); starPath(ctx, spikes, outer*size*0.5, inner*size*0.5); ctx.fill();
    const g = ctx.createRadialGradient(-size*0.12,-size*0.12, size*0.03, 0,0, size*0.5); g.addColorStop(0, '#ffffff'); g.addColorStop(0.25, body); g.addColorStop(1, 'rgba(255,255,255,0.0)');
    ctx.fillStyle=g; ctx.shadowBlur=0; ctx.globalCompositeOperation='lighter'; ctx.beginPath(); starPath(ctx, spikes, outer*size*0.5, inner*size*0.5); ctx.fill(); ctx.restore();
    const tex = new THREE.CanvasTexture(c); tex.anisotropy=8; tex.generateMipmaps=true; tex.needsUpdate=true; return tex;
  }
  function starPath(ctx, spikes, outerR, innerR){ let rot = 0, x = 0, y = 0; ctx.moveTo(outerR, 0); for(let i=0;i<spikes;i++){ x = Math.cos(rot + Math.PI/spikes) * innerR; y = Math.sin(rot + Math.PI/spikes) * innerR; ctx.lineTo(x,y); rot += (Math.PI*2)/spikes; x = Math.cos(rot) * outerR; y = Math.sin(rot) * outerR; ctx.lineTo(x,y);} ctx.closePath(); }
  const starTex = makeStarTexture(192);

  // ====== ROSE SURFACE (blossom only)
  // Tr·∫£ v·ªÅ gi√° tr·ªã <0 khi ·ªü b√™n trong b√¥ng hoa (petalized sphere quanh tr·ª•c Oy)
  function fHeart(x,y,z){
    const eps=1e-8; 
    const r=Math.sqrt(x*x+y*y+z*z)+eps;           // kho·∫£ng c√°ch t·ªõi t√¢m
    const th=Math.acos(Math.max(-1,Math.min(1,y/r))); // g√≥c t·ª´ +Y (0..œÄ)
    const ph=Math.atan2(z,x);                      // -œÄ..œÄ, quanh Oy
    const PETALS=7;                                // s·ªë c√°nh (b·∫°n c√≥ th·ªÉ ƒë·ªïi)
    const pet= Math.cos(PETALS*ph);                // g·ª£n theo g√≥c
    const band= Math.pow(Math.sin(th),2.2);        // m·∫°nh ·ªü x√≠ch ƒë·∫°o
    const profile= 0.80 + 0.20*Math.pow(Math.cos(th),2.0); // thon ·ªü c·ª±c
    const R0=1.32, AMP=0.33;                       // b√°n k√≠nh & bi√™n ƒë·ªô c√°nh
    return r - (R0*profile*(1.0 + AMP*pet*band));  // <0: trong b√¥ng
  }

  // uniform directions via Fibonacci sphere
  function fiboDirections(n){
    const dirs = new Float32Array(n*3);
    const PHI = (1+Math.sqrt(5))/2;
    for(let i=0;i<n;i++){
      const t=i/n, lat=Math.asin(2*t-1), lon=2*Math.PI*i/PHI;
      const x=Math.cos(lat)*Math.cos(lon), y=Math.sin(lat), z=Math.cos(lat)*Math.sin(lon);
      dirs[i*3]=x; dirs[i*3+1]=y; dirs[i*3+2]=z;
    }
    return dirs;
  }
  function rayHitOnSurface(dx,dy,dz){ const RMAX=3, ITER=24; let lo=0, hi=RMAX; for(let k=0;k<ITER;k++){ const mid=0.5*(lo+hi); const v=fHeart(dx*mid,dy*mid,dz*mid); if(v>0) hi=mid; else lo=mid; } const r=0.5*(lo+hi); return [dx*r*HEART_SCALE, dy*r*HEART_SCALE, dz*r*HEART_SCALE]; }

  // ====== HEART POINTS (5000) ======
  const STAR_COUNT=5000; const starGeo=new THREE.BufferGeometry();
  const positions=new Float32Array(STAR_COUNT*3); const velocities=new Float32Array(STAR_COUNT*3);
  const targets=new Float32Array(STAR_COUNT*3); const colors=new Float32Array(STAR_COUNT*3);
  const starMat=new THREE.PointsMaterial({ map:starTex, vertexColors:true, size:0.13, sizeAttenuation:true, transparent:true, alphaTest:0.1, depthWrite:true, blending:THREE.AdditiveBlending });
  // pre-create color attribute (some drivers require existing attribute before the first frame)
  starGeo.setAttribute('color', new THREE.BufferAttribute(colors,3));
  const heartStars=new THREE.Points(starGeo, starMat); heartStars.visible=false; contentGroup.add(heartStars);

  (function sampleTargets(){ const dirs=fiboDirections(STAR_COUNT); const qStand=new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.PI/2,0,0)); const v=new THREE.Vector3(); for(let i=0;i<STAR_COUNT;i++){ const dx=dirs[i*3],dy=dirs[i*3+1],dz=dirs[i*3+2]; const p=rayHitOnSurface(dx,dy,dz); v.set(p[0],p[1],p[2]).applyQuaternion(qStand); targets[i*3]=v.x; targets[i*3+1]=v.y; targets[i*3+2]=v.z; } const L=new THREE.Vector3(-0.25,0.85,0.35).normalize();
    for(let i=0;i<STAR_COUNT;i++){
      const x=targets[i*3], y=targets[i*3+1], z=targets[i*3+2];
      const n=new THREE.Vector3(x,y,z).normalize();
      const h=Math.max(0,n.dot(L));             // highlight theo h∆∞·ªõng s√°ng
      // ph·ªëi m√†u h·ªìng/ƒë·ªè cho to√†n b·ªô b√¥ng, kh√¥ng c√≤n ph·∫ßn xanh l√°/c√†nh
      const r = 0.78 + 0.22*h;
      const g = 0.18 + 0.12*h;
      const b = 0.26 + 0.12*h;
      colors[i*3]=r; colors[i*3+1]=g; colors[i*3+2]=b;
    }
  })();

  // ====== RING UNDER HEART ======
  const ringGroup = new THREE.Group(); ringGroup.visible=false; contentGroup.add(ringGroup);
  const ringTex = makeStarTexture(144,5,.40,1.0,'#ffffff');
  const ringMat = new THREE.PointsMaterial({ map:ringTex, size:0.11, sizeAttenuation:true, transparent:true, alphaTest:0.1, depthWrite:false, blending:THREE.AdditiveBlending, color:0xffffff});
  const RING_COUNT=72; const ringGeo=new THREE.BufferGeometry(); const ringPos=new Float32Array(RING_COUNT*3);
  const R=HEART_SCALE*2.0, YR=-HEART_SCALE*0.62; for(let i=0;i<RING_COUNT;i++){ const a=i/RING_COUNT*Math.PI*2; ringPos[i*3]=Math.cos(a)*R; ringPos[i*3+1]=YR; ringPos[i*3+2]=Math.sin(a)*R*0.85; } ringGeo.setAttribute('position', new THREE.BufferAttribute(ringPos,3)); ringGroup.add(new THREE.Points(ringGeo, ringMat));

  // ====== 4 PHOTO PLANES (URLs around Oy) ======
  // üëâ ƒêi·ªÅn 4 URL c·ªßa b·∫°n t·∫°i ƒë√¢y (gi·ªØ nguy√™n 4 ph·∫ßn t·ª≠). C√≥ th·ªÉ ƒë·ªÉ r·ªóng, s·∫Ω d√πng b·∫£n ghi "No Image" ƒë·ªÉ demo.
  const PHOTO_URLS = [
    "https://scontent.fsgn19-1.fna.fbcdn.net/v/t39.30808-6/538025016_1043356077878114_990406986168860085_n.jpg?_nc_cat=104&ccb=1-7&_nc_sid=6ee11a&_nc_ohc=WpDdj5reXtwQ7kNvwFtf5ci&_nc_oc=AdmSKNTmybTek9cF9oyNNb7LYnIHgrE7inMF9yZayx9SaEUjnPWs9btQcTJR6N6BbYCVkz9ge2BHfXM19TBQUxBR&_nc_zt=23&_nc_ht=scontent.fsgn19-1.fna&_nc_gid=Pzdts7--7JEZiB3wgCbxkA&oh=00_AfcD3zAG-eYx8fiqrQA-mgdXtj16pVBeayOaNnxrbjx9nA&oe=68FC0A61",
    "https://scontent.fsgn19-1.fna.fbcdn.net/v/t39.30808-6/476340607_904469608433429_3032761185442438227_n.jpg?_nc_cat=101&ccb=1-7&_nc_sid=833d8c&_nc_ohc=dEHfBNSBk3IQ7kNvwHAJ0Ph&_nc_oc=Adkq1EfinFXGgKeXadm6UcVJgLXwXflv2A6uXzzWvuRbJAXu9RVhZiZEkPCtS9adWn64bu_lOffUuoc849R75SZ3&_nc_zt=23&_nc_ht=scontent.fsgn19-1.fna&_nc_gid=KrZJJLjHo2RYfAlz1e7BwA&oh=00_Aff_x5QhifpwP1O8iuKg9VuMTEE1I9ywr5IV_gzi7e7Rxw&oe=68FC312E",
    "https://scontent.fsgn19-1.fna.fbcdn.net/v/t39.30808-6/474588288_894484952765228_8634554802337046065_n.jpg?_nc_cat=105&ccb=1-7&_nc_sid=833d8c&_nc_ohc=ll2DehZzfR8Q7kNvwGYJeKJ&_nc_oc=Adl-yfO9llOM7go45s5HMqHx8nzKIBmCodCjnyjLaW52Dtgs-BcoFXObwQSK9wSWYwUlyb_OdRoa3DvsxRKSsAsZ&_nc_zt=23&_nc_ht=scontent.fsgn19-1.fna&_nc_gid=V7wPOCf0gPPRCJO7iCsISA&oh=00_Afds-4ceBjOWOjTrO-srzwQoUu8LPvQpcKEvBSnTE5KHtw&oe=68FC2A35",
    "https://scontent.fsgn19-1.fna.fbcdn.net/v/t39.30808-6/476252590_905098345037222_6207561302129260720_n.jpg?_nc_cat=100&ccb=1-7&_nc_sid=833d8c&_nc_ohc=qKwLAyB4SckQ7kNvwEUTOpd&_nc_oc=AdlVDAtaemg4n6fhd450qC5_umI8PlyE83qwqvnEovAdFDjh6cRqXtrwZogV4XlOq0BvbnwYI3JSyuJjhKKn4T1n&_nc_zt=23&_nc_ht=scontent.fsgn19-1.fna&_nc_gid=n-vlfMzU3_SxXxnH4ibSVw&oh=00_AfdGs6Srob88MHAmRFGwCuEp_X2_3zhAVUbqMbs8ceI3Xg&oe=68FC1D78"
  ];
  const photoGroup = new THREE.Group(); photoGroup.visible = false; contentGroup.add(photoGroup);
  const loader = new THREE.TextureLoader(); loader.setCrossOrigin('anonymous');
  const PHOTO_SIZE = HEART_SCALE * 0.8; // nh·ªè h∆°n tim
  const OFFSET = HEART_SCALE * 0.14;    // c√°ch m·∫∑t tim 1 ch√∫t
  function makeFallbackTexture(){ const c=document.createElement('canvas'); c.width=c.height=256; const ctx=c.getContext('2d'); ctx.fillStyle='#1b1b2a'; ctx.fillRect(0,0,256,256); ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.strokeRect(20,20,216,216); ctx.fillStyle='#ff5a7a'; ctx.font='bold 28px Poppins,Arial,Helvetica,sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('No Image',128,128); return new THREE.CanvasTexture(c); }
  function createPhotoPlane(tex, posVec){ const geo=new THREE.PlaneGeometry(1,1); const mat=new THREE.MeshBasicMaterial({ map:tex, transparent:true, side:THREE.DoubleSide }); const mesh=new THREE.Mesh(geo,mat); const n=posVec.clone().normalize(); mesh.position.copy(posVec.clone().add(n.clone().multiplyScalar(OFFSET))); const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), n); mesh.setRotationFromQuaternion(q); mesh.scale.set(PHOTO_SIZE, PHOTO_SIZE, 1); mesh.renderOrder=3; return mesh; }
  function placeFourPhotos(){ const qStand=new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.PI/2,0,0)); for(let k=0;k<4;k++){ const ang=k*Math.PI/2; const dx=Math.cos(ang), dy=Math.sin(ang), dz=0; const p=rayHitOnSurface(dx,dy,dz); const pos=new THREE.Vector3(p[0],p[1],p[2]).applyQuaternion(qStand); const url=PHOTO_URLS[k]; if(url&&/^https?:\/\//.test(url)){ loader.load(url, (tex)=> photoGroup.add(createPhotoPlane(tex,pos)), undefined, ()=>{ photoGroup.add(createPhotoPlane(makeFallbackTexture(), pos)); }); } else { photoGroup.add(createPhotoPlane(makeFallbackTexture(), pos)); } } }

  // ====== EXPLOSION/ASSEMBLY ======
  let explodeStart=0, assembleStart=0; const SPRING=0.55, DAMP=0.82;
  function triggerExplosion(){ phase='explode'; explodeStart=performance.now(); heartStars.visible=true; const origin=specialStar.getWorldPosition(new THREE.Vector3()); for(let i=0;i<STAR_COUNT;i++){ positions[i*3]=origin.x; positions[i*3+1]=origin.y; positions[i*3+2]=origin.z; const dir=new THREE.Vector3(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1).normalize(); const speed=1.15+Math.random()*2.6; velocities[i*3]=dir.x*speed; velocities[i*3+1]=dir.y*speed; velocities[i*3+2]=dir.z*speed; } starGeo.setAttribute('position', new THREE.BufferAttribute(positions,3)); starGeo.setAttribute('color', new THREE.BufferAttribute(colors,3)); starGeo.computeBoundingSphere(); specialStar.visible=false; setTimeout(()=>{ phase='assemble'; assembleStart=performance.now(); }, 700); }
  function onFormed(){ if(phase!=='formed') return; if(!titleShown){ const t=document.getElementById('bigTitle'); if(t) t.classList.add('show'); titleShown=true; } ringGroup.visible=true; photoGroup.visible=true; placeFourPhotos(); }

  addEventListener('click', (e)=>{ if(phase!=='idle') return; const rect = renderer.domElement.getBoundingClientRect(); const cx = (e.clientX!==undefined?e.clientX:0); const cy = (e.clientY!==undefined?e.clientY:0); pointer.x = ((cx-rect.left)/rect.width)*2-1; pointer.y = -((cy-rect.top)/rect.height)*2+1; raycaster.setFromCamera(pointer, camera); const hit = raycaster.intersectObject(specialStar, true); if(hit.length===0) return; triggerExplosion(); });

  // ====== LOOP ======
  let lastTime=performance.now();
  function animate(){ requestAnimationFrame(animate); const now=performance.now(); const dt=Math.min(0.033,(now-lastTime)/1000); lastTime=now; starGroup.rotation.y+=0.0007; if(!isDragging) yaw += autoRotate*dt*0.8; contentGroup.rotation.set(pitch, yaw, 0); if(ringGroup.visible) ringGroup.rotation.y += 0.35*dt; if(phase==='idle' && specialStar.visible){
      sparkT += dt;
      // gentle spin
      specialStar.rotation.y += 0.25*dt;
      // pulse glow
      specialGlow.material.opacity = 0.65 + 0.35*Math.sin(now*0.004);
      specialGlow.material.needsUpdate = true;
      // orbiting sparkles
      const R=1.2; for(let i=0;i<sparkOrbiters.length;i++){ const a = sparkT*1.6 + i*(Math.PI*2/sparkOrbiters.length); sparkOrbiters[i].position.set(Math.cos(a)*R, Math.sin(a*1.7)*0.4, Math.sin(a)*R); }
    }
    if(phase==='explode' || phase==='assemble' || phase==='formed'){ heartStars.visible=true; for(let i=0;i<STAR_COUNT;i++){ const i3=i*3; if(phase==='explode'){ velocities[i3]*=0.985; velocities[i3+1]*=0.985; velocities[i3+2]*=0.985; positions[i3] += velocities[i3]*dt*2.2; positions[i3+1] += velocities[i3+1]*dt*2.2; positions[i3+2] += velocities[i3+2]*dt*2.2; } else { const dx=targets[i3]-positions[i3]; const dy=targets[i3+1]-positions[i3+1]; const dz=targets[i3+2]-positions[i3+2]; velocities[i3] = velocities[i3]*DAMP + dx*SPRING; velocities[i3+1] = velocities[i3+1]*DAMP + dy*SPRING; velocities[i3+2] = velocities[i3+2]*DAMP + dz*SPRING; positions[i3] += velocities[i3]*dt*0.13; positions[i3+1] += velocities[i3+1]*dt*0.13; positions[i3+2] += velocities[i3+2]*dt*0.13; } } starGeo.attributes.position.needsUpdate=true; if(phase==='explode' && (now-explodeStart)>700){ phase='assemble'; assembleStart=now; } if(phase==='assemble' && (now-assembleStart)>2000){ phase='formed'; onFormed(); } }
    // --- update meteors ---
    if(meteorGroup){ for(let i=0;i<meteors.length;i++){ const m=meteors[i]; m.life -= dt; m.sprite.position.addScaledVector(m.vel, dt); if(m.life<=0){ spawnMeteor(i); } } }

    renderer.render(scene, camera); }
  animate();

  // ====== TESTS ======
  (function runSelfTests(){ try{ 
    console.log('%c[TEST] Start','color:#9fe');
    // Existing tests (kept)
    console.assert(STAR_COUNT===5000,'5000 stars');
    console.assert(Array.isArray(PHOTO_URLS)&&PHOTO_URLS.length===4,'PHOTO_URLS has 4 items');
    console.assert(fHeart(0,0,0)<0,'fHeart(0,0,0)<0 for bracketing');
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity; for(let i=0;i<STAR_COUNT;i++){ const x=targets[i*3], y=targets[i*3+1]; if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; } console.assert((maxX-minX)>5.0 && (maxY-minY)>4.4,'Heart bounds ok');

    // Added tests
    console.assert(typeof fiboDirections==='function','fiboDirections defined');
    const dtest=fiboDirections(10); console.assert(dtest.length===30,'fiboDirections size ok');
    let normOk=true; for(let i=0;i<5;i++){ const x=dtest[i*3],y=dtest[i*3+1],z=dtest[i*3+2]; const n=Math.hypot(x,y,z); if(!(isFinite(n)&&n>0.99&&n<1.01)) normOk=false; }
    console.assert(normOk,'fiboDirections unit vectors');
    console.assert(meteors.length===METEOR_N,'meteors count ok');
    console.assert(specialStar.children.length>0,'special star built');
    console.log('%c[TEST] Passed','color:#9f9'); 
  }catch(err){ console.error('[TEST] Failed', err); } })();
})();
</script>
</body>
</html>
